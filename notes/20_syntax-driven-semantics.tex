\documentclass[11pt,a4paper]{article}

\usepackage{times}

\usepackage{umut,utheorem}
\usepackage{cgmacros2e}
\usepackage{tikz-qtree}
\usepackage{linguex}
\renewcommand{\refdash}{}

\title{Syntax-driven semantic composition\\ \small (Lecture notes for COGS 543)}
\author{Umut \"Ozge}

\begin{document}
\maketitle

\noindent We start by endorsing \emph{the principle of compositionality}, which says that:

\ex. The meaning of an expression is a function of the meanings of its parts and the way they combine.

We use ``is a function of'' in the mathematical sense: if you know the meanings of basic components
and the way they come together, then you know the meaning.  Leave aside ``the
meaning of basic components'' for now, but what is meant by ``the way they
combine?'' We all have an intuitive grasp of the principle of compositionality. Take the sequence,

\ex.\label{coffeeseq}  black, coffee, maker

Here are three ways to combine them into a whole:

\ex.\label{coffeeseqB} \a.\label{coffeeseqL} ((black coffee) maker)
\b.\label{coffeeseqR} (black (coffee maker))
\b.\label{coffeeseqF}  (black coffee maker)


What the first two means is clear, the third one is a mystery, unless you are smuggling in some inner parentheses. In this tiny example there is more than bringing items together; there is also order in coming together. Now we get a little technical and have a closer look.

Call a process which takes as input something like \xref{coffeeseq} and produces an output like those in \xref{coffeeseqB} a ``combinatory process''.  If you want to talk about just the output, call it ``combination''. They are different things. See below.

In characterizing combinatory processes, one crucial parameter is the number of items that you can combine in a single step. We agree on this number to be two,

\ex. A combinatory process can combine at most two items at a time,\footnote{Don't get bothered for now by why I wrote ``at most'' instead of ``exactly''.}

eliminating \xref{coffeeseqF}, which combines three items in a single step.

With these conventions at hand, given a sequence of three items, represented as the ordered triple \sysm{(a,b,c)}, there are three distinct combinatory processes:\footnote{{\bf Question:} How many distinct combinatory processes are there for \sysm{n} items?}

\ex. 
\a. First combine \sysm{a} with \sysm{b}, then combine \sysm{c} with the result: \sysm{\{\{a,b\},c\}};
\b.\label{cprocJump} First combine \sysm{a} with \sysm{c}, then combine \sysm{b} with the result: \sysm{\{\{a,c\},b\}};
\b. First combine \sysm{b} with \sysm{c}, then combine \sysm{a} with the result: \sysm{\{\{b,c\},a\}}.


I used set notation in representing the results of combinatory processes, because, for the moment, we do not see combining \sysm{x} with \sysm{y} as different from combining \sysm{y} with \sysm{x}; the arguments to the combination procedure are unordered. But be careful that the combinatory steps are ordered -- first combine so and so, \emph{then} so and so.

Also observe that \xref{cprocJump} is different from the other two processes. It combines two items that are not adjacent in the input sequence. Combinatory processes, as we define them for now, are capable of scanning sequences and picking any elements they like.  


For the three item case, the number of distinct combinatory processes and the number of distinct combinations are equal.  It starts to get interesting, when you have a more crowded string of items as input to a combinatory process. Take \sysm{(a,b,c,d)} for instance. Below are two distinct combinatory processes resulting in identical combinations, 

\ex.\label{mapping}\a.  First combine \sysm{a} with \sysm{c}; then \sysm{b} with \sysm{d}; then \sysm{\{a,c\}} with \sysm{\{b,d\}}: \sysm{\{\{a,c\},\{b,d\}\}}.  
\b. First combine \sysm{b} with \sysm{d}; then \sysm{a} with \sysm{c}; then \sysm{\{a,c\}} with \sysm{\{b,d\}}: \sysm{\{\{a,c\},\{b,d\}\}}.  


It is in this sense that combinatory processes and combinations are different things; the mapping from processes to combinations is many-to-one.\footnote{{\bf Question:} How many distinct combinations are there for $n$ items?} 

Now comes some useful notational machinery. First we get rid of this ``first combine\ldots then\ldots'' idiom. Here is how we represent combinatory processes in \xref{mapping}. 

\ex. 
\fbox{\cgex{8}{
$a$ & $\quad$ & $b$ & $\quad$ & $c$ & $\quad$ & $d$ & $\quad$\\
$a$ & $\quad$ & $c$ & $\quad$ & $b$ & $\quad$ & $d$ & $\quad$\\
\cgline{3}{} \\
\cgres{3}{\{a, c\}} \\
&& &&\cgline{3}{} \\
&& &&\cgres{3}{\{b, d\}} \\
\cgline{8}{}\\
\cgres{8}{\{\{a, c\},\{b, d\}\}}
}}
\fbox{\cgex{8}{
$a$ & $\quad$ & $b$ & $\quad$ & $c$ & $\quad$ & $d$ & $\quad$\\
$a$ & $\quad$ & $c$ & $\quad$ & $b$ & $\quad$ & $d$ & $\quad$\\
&& &&\cgline{3}{} \\
&& &&\cgres{3}{\{b, d\}} \\
\cgline{3}{} \\
\cgres{3}{\{a, c\}} \\
\cgline{8}{}\\
\cgres{8}{\{\{a, c\},\{b, d\}\}}
}}

The device we use to be able to combine non-adjacent items is permuting items as we wish, like we did while swapping $b$ and $c$ above.

Combinations can be represented as binary trees, linearly non-ordered (= flipping the branches of any node from left to right does not result in a distinct tree). Here is how we represent \xref{mapping}:

\ex. \Tree [.{.} [.{.}  a c ] [.{.} b d ] ]


\newpage
Now it is time to answer some questions in the text.  

Question: How many distinct combinatory processes are there for
\sysm{n} items?

Answer: Given a set of \sysm{n} items, atomic or complex, give them a certain order \sysm{\{a_1,a_2,\ldots a_n\}}. If you pick $a_1$ there are $n-1$ items to combine it with; then pick $a_2$, don't look back because you already combined $a_1$ and $a_2$, so there are $n-2$ possibilities left. Proceeding like this you will end up with $n-1 + n-2 +\ldots + 1$ possibilities, which is $\frac{n(n-1)}{2}$ by Gauss' law. This was the first pass of combinations. After this pass, picking one of the possible combinations, you are left with $n-1$ items in your set. By the same reasoning as above you have  $\frac{(n-1)(n-2)}{2}$ possibilities for the second pass. For the first two passes you have $\frac{n(n-1)}{2}\frac{(n-1)(n-2)}{2}$ possibilities. You need to proceed until you have only one item left in your set. Therefore, the number we are after is:

$$
\frac{n\prod_{i=1}^{n-1} i^2}{2^{n-1}} = \frac{n! (n-1)!}{2^{n-1}}
$$


\bibliographystyle{natgig}
\bibliography{ozge}
\end{document}

